{"ast":null,"code":"/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber|undefined} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce|undefined} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\nimport { convertElement } from 'hast-util-is-element';\nimport { findAfter } from 'unist-util-find-after';\nconst searchLineFeeds = /\\n/g;\nconst searchTabOrSpaces = /[\\t ]+/g;\nconst br = convertElement('br');\nconst p = convertElement('p');\nconst cell = convertElement(['th', 'td']);\nconst row = convertElement('tr'); // Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\n\nconst notRendered = convertElement([// List from: <https://html.spec.whatwg.org/#hidden-elements>\n'datalist', 'head', 'noembed', 'noframes', 'noscript', // Act as if we support scripting.\n'rp', 'script', 'style', 'template', 'title', // Hidden attribute.\nhidden, // From: <https://html.spec.whatwg.org/#flow-content-3>\nclosedDialog]); // See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\n\nconst blockOrCaption = convertElement(['address', // Flow content\n'article', // Sections and headings\n'aside', // Sections and headings\n'blockquote', // Flow content\n'body', // Page\n'caption', // `table-caption`\n'center', // Flow content (legacy)\n'dd', // Lists\n'dialog', // Flow content\n'dir', // Lists (legacy)\n'dl', // Lists\n'dt', // Lists\n'div', // Flow content\n'figure', // Flow content\n'figcaption', // Flow content\n'footer', // Flow content\n'form,', // Flow content\n'h1', // Sections and headings\n'h2', // Sections and headings\n'h3', // Sections and headings\n'h4', // Sections and headings\n'h5', // Sections and headings\n'h6', // Sections and headings\n'header', // Flow content\n'hgroup', // Sections and headings\n'hr', // Flow content\n'html', // Page\n'legend', // Flow content\n'listing', // Flow content (legacy)\n'main', // Flow content\n'menu', // Lists\n'nav', // Sections and headings\n'ol', // Lists\n'p', // Flow content\n'plaintext', // Flow content (legacy)\n'pre', // Flow content\n'section', // Sections and headings\n'ul', // Lists\n'xmp' // Flow content (legacy)\n]);\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @param {Options} [options={}]\n * @returns {string}\n */\n\nexport function toText(node) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  const children = node.children || [];\n  const block = blockOrCaption(node);\n  const whitespace = inferWhitespace(node, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  });\n  let index = -1;\n  /** @type {Array.<string|BreakNumber>} */\n\n  let results;\n  /** @type {string|BreakNumber} */\n\n  let value;\n  /** @type {number|undefined} */\n\n  let count; // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {\n      whitespace,\n      breakBefore: true,\n      breakAfter: true\n    });\n  } // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n  // 2.  Let results be a new empty list.\n\n\n  results = []; // 3.  For each child node node of this element:\n\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat( // @ts-ignore Looks like a parent.\n    innerTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? null : block,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : block\n    }));\n  } // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n\n\n  index = -1;\n  /** @type {Array.<string>} */\n\n  const result = [];\n\n  while (++index < results.length) {\n    value = results[index];\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value;\n    } else if (value) {\n      if (count) result.push('\\n'.repeat(count));\n      count = 0;\n      result.push(value);\n    }\n  } // 7.  Return the concatenation of the string items in results.\n\n\n  return result.join('');\n}\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\n\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options);\n  }\n\n  if (node.type === 'text') {\n    return [options.whitespace === 'normal' ? collectText(node, options) : collectPreText(node)];\n  }\n\n  return [];\n}\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\n\n\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, options);\n  const children = node.children || [];\n  let index = -1;\n  /** @type {Array.<string|BreakNumber>} */\n\n  let items = [];\n  /** @type {BreakNumber|undefined} */\n\n  let prefix;\n  /** @type {BreakNumber|BreakForce|undefined} */\n\n  let suffix; // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n\n  if (notRendered(node)) {\n    return items;\n  } // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n  // See `collectText` for step 4.\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n\n\n  if (br(node)) {\n    suffix = '\\n';\n  } // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n';\n  } // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2;\n    suffix = 2;\n  } // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1;\n    suffix = 1;\n  } // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n\n\n  while (++index < children.length) {\n    items = items.concat(innerTextCollection(children[index], node, {\n      whitespace,\n      breakBefore: index ? undefined : prefix,\n      breakAfter: index < children.length - 1 ? br(children[index + 1]) : suffix\n    }));\n  } // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n\n\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t');\n  } // Add the pre- and suffix.\n\n\n  if (prefix) items.unshift(prefix);\n  if (suffix) items.push(suffix);\n  return items;\n}\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\n\n\nfunction collectText(node, options) {\n  const value = String(node.value);\n  /** @type {Array.<string>} */\n\n  const lines = [];\n  /** @type {Array.<string>} */\n\n  const result = [];\n  let start = 0;\n  let index = -1;\n  /** @type {RegExpMatchArray|null} */\n\n  let match;\n  /** @type {number} */\n\n  let end;\n  /** @type {string|undefined} */\n\n  let join;\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start;\n    match = searchLineFeeds.exec(value); // @ts-expect-error: `index` is set.\n\n    end = match ? match.index : value.length;\n    lines.push( // Any sequence of collapsible spaces and tabs immediately preceding or\n    // following a segment break is removed.\n    trimAndCollapseSpacesAndTabs( // [...] ignoring bidi formatting characters (characters with the\n    // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n    // they were not there.\n    value.slice(start, end).replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''), options.breakBefore, options.breakAfter));\n    start = end + 1;\n  } // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n\n\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (lines[index].charCodeAt(lines[index].length - 1) === 0x200b\n    /* ZWSP */\n    || index < lines.length - 1 && lines[index + 1].charCodeAt(0) === 0x200b\n    /* ZWSP */\n    ) {\n      result.push(lines[index]);\n      join = '';\n    } // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join);\n      result.push(lines[index]);\n      join = ' ';\n    }\n  }\n\n  return result.join('');\n}\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\n\n\nfunction collectPreText(node) {\n  return String(node.value);\n}\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\n\n\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  const result = [];\n  let start = 0;\n  /** @type {RegExpMatchArray|null} */\n\n  let match;\n  /** @type {number} */\n\n  let end;\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start;\n    match = searchTabOrSpaces.exec(value); // @ts-expect-error: `index` is set.\n\n    end = match ? match.index : value.length; // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n\n    if (!start && !end && match && !breakBefore) {\n      result.push('');\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end));\n    }\n\n    start = match ? end + match[0].length : end;\n  } // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  // @ts-expect-error: `end` is defined.\n\n\n  if (start !== end && !breakAfter) {\n    result.push('');\n  }\n\n  return result.join(' ');\n}\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\n\n\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  let props;\n\n  if (node.type === 'element') {\n    props = node.properties || {};\n\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre';\n\n      case 'nobr':\n        return 'nowrap';\n\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre';\n\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace;\n\n      case 'textarea':\n        return 'pre-wrap';\n\n      default:\n    }\n  }\n\n  return options.whitespace;\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden);\n}\n/** @type {TestFunctionAnything} */\n\n\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open;\n}","map":{"version":3,"names":["convertElement","findAfter","searchLineFeeds","searchTabOrSpaces","br","p","cell","row","notRendered","hidden","closedDialog","blockOrCaption","toText","node","options","children","block","whitespace","inferWhitespace","breakBefore","breakAfter","index","results","value","count","type","collectText","length","concat","innerTextCollection","result","undefined","push","repeat","join","parent","collectElement","collectPreText","items","prefix","suffix","unshift","String","lines","start","match","end","lastIndex","exec","trimAndCollapseSpacesAndTabs","slice","replace","charCodeAt","props","properties","tagName","wrap","noWrap","Boolean","open"],"sources":["C:/Users/rudra/Documents/original_website/The-Weirdos-NFT-Website-Starter-Code/node_modules/hast-util-to-text/index.js"],"sourcesContent":["/**\n * @typedef {import('hast-util-is-element').TestFunctionAnything} TestFunctionAnything\n * @typedef {import('hast').Parent['children'][number]} HastChild\n * @typedef {import('hast').Text} HastText\n * @typedef {import('hast').Comment} HastComment\n * @typedef {import('hast').Root} HastRoot\n * @typedef {import('hast').Element} HastElement\n * @typedef {import('hast').Properties} HastProperties\n * @typedef {HastChild|HastRoot} HastNode\n * @typedef {HastRoot|HastElement} HastParent\n *\n * @typedef {'normal'|'pre'|'nowrap'|'pre-wrap'} Whitespace\n * @typedef {boolean} BreakValue\n * @typedef {1|2} BreakNumber\n * @typedef {'\\n'} BreakForce\n * @typedef {BreakValue|BreakNumber|undefined} BreakBefore\n * @typedef {BreakValue|BreakNumber|BreakForce|undefined} BreakAfter\n *\n * @typedef CollectionOptions\n * @property {Whitespace} whitespace\n * @property {BreakBefore} breakBefore\n * @property {BreakAfter} breakAfter\n *\n * @typedef Options\n *   Configuration.\n * @property {Whitespace} [whitespace='normal']\n *   Initial CSS whitespace setting to use.\n */\n\nimport {convertElement} from 'hast-util-is-element'\nimport {findAfter} from 'unist-util-find-after'\n\nconst searchLineFeeds = /\\n/g\nconst searchTabOrSpaces = /[\\t ]+/g\n\nconst br = convertElement('br')\nconst p = convertElement('p')\nconst cell = convertElement(['th', 'td'])\nconst row = convertElement('tr')\n\n// Note that we don’t need to include void elements here as they don’t have text.\n// See: <https://github.com/wooorm/html-void-elements>\nconst notRendered = convertElement([\n  // List from: <https://html.spec.whatwg.org/#hidden-elements>\n  'datalist',\n  'head',\n  'noembed',\n  'noframes',\n  'noscript', // Act as if we support scripting.\n  'rp',\n  'script',\n  'style',\n  'template',\n  'title',\n  // Hidden attribute.\n  hidden,\n  // From: <https://html.spec.whatwg.org/#flow-content-3>\n  closedDialog\n])\n\n// See: <https://html.spec.whatwg.org/#the-css-user-agent-style-sheet-and-presentational-hints>\nconst blockOrCaption = convertElement([\n  'address', // Flow content\n  'article', // Sections and headings\n  'aside', // Sections and headings\n  'blockquote', // Flow content\n  'body', // Page\n  'caption', // `table-caption`\n  'center', // Flow content (legacy)\n  'dd', // Lists\n  'dialog', // Flow content\n  'dir', // Lists (legacy)\n  'dl', // Lists\n  'dt', // Lists\n  'div', // Flow content\n  'figure', // Flow content\n  'figcaption', // Flow content\n  'footer', // Flow content\n  'form,', // Flow content\n  'h1', // Sections and headings\n  'h2', // Sections and headings\n  'h3', // Sections and headings\n  'h4', // Sections and headings\n  'h5', // Sections and headings\n  'h6', // Sections and headings\n  'header', // Flow content\n  'hgroup', // Sections and headings\n  'hr', // Flow content\n  'html', // Page\n  'legend', // Flow content\n  'listing', // Flow content (legacy)\n  'main', // Flow content\n  'menu', // Lists\n  'nav', // Sections and headings\n  'ol', // Lists\n  'p', // Flow content\n  'plaintext', // Flow content (legacy)\n  'pre', // Flow content\n  'section', // Sections and headings\n  'ul', // Lists\n  'xmp' // Flow content (legacy)\n])\n\n/**\n * Implementation of the `innerText` getter:\n * <https://html.spec.whatwg.org/#the-innertext-idl-attribute>\n * Note that we act as if `node` is being rendered, and as if we’re a\n * CSS-supporting user agent.\n *\n * @param {HastNode} node\n * @param {Options} [options={}]\n * @returns {string}\n */\nexport function toText(node, options = {}) {\n  /** @type {Array.<HastChild>} */\n  // @ts-ignore looks like a parent.\n  const children = node.children || []\n  const block = blockOrCaption(node)\n  const whitespace = inferWhitespace(node, {\n    whitespace: options.whitespace || 'normal',\n    breakBefore: false,\n    breakAfter: false\n  })\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let results\n  /** @type {string|BreakNumber} */\n  let value\n  /** @type {number|undefined} */\n  let count\n\n  // Treat `text` and `comment` as having normal white-space.\n  // This deviates from the spec as in the DOM the node’s `.data` has to be\n  // returned.\n  // If you want that behavior use `hast-util-to-string`.\n  // All other nodes are later handled as if they are `element`s (so the\n  // algorithm also works on a `root`).\n  // Nodes without children are treated as a void element, so `doctype` is thus\n  // ignored.\n  if (node.type === 'text' || node.type === 'comment') {\n    return collectText(node, {whitespace, breakBefore: true, breakAfter: true})\n  }\n\n  // 1.  If this element is not being rendered, or if the user agent is a\n  //     non-CSS user agent, then return the same value as the textContent IDL\n  //     attribute on this element.\n  //\n  //     Note: we’re not supporting stylesheets so we’re acting as if the node\n  //     is rendered.\n  //\n  //     If you want that behavior use `hast-util-to-string`.\n  //     Important: we’ll have to account for this later though.\n\n  // 2.  Let results be a new empty list.\n  results = []\n\n  // 3.  For each child node node of this element:\n  while (++index < children.length) {\n    // 3.1. Let current be the list resulting in running the inner text\n    //      collection steps with node.\n    //      Each item in results will either be a JavaScript string or a\n    //      positive integer (a required line break count).\n    // 3.2. For each item item in current, append item to results.\n    results = results.concat(\n      // @ts-ignore Looks like a parent.\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? null : block,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : block\n      })\n    )\n  }\n\n  // 4.  Remove any items from results that are the empty string.\n  // 5.  Remove any runs of consecutive required line break count items at the\n  //     start or end of results.\n  // 6.  Replace each remaining run of consecutive required line break count\n  //     items with a string consisting of as many U+000A LINE FEED (LF)\n  //     characters as the maximum of the values in the required line break\n  //     count items.\n  index = -1\n  /** @type {Array.<string>} */\n  const result = []\n\n  while (++index < results.length) {\n    value = results[index]\n\n    if (typeof value === 'number') {\n      if (count !== undefined && value > count) count = value\n    } else if (value) {\n      if (count) result.push('\\n'.repeat(count))\n      count = 0\n      result.push(value)\n    }\n  }\n\n  // 7.  Return the concatenation of the string items in results.\n  return result.join('')\n}\n\n/**\n * <https://html.spec.whatwg.org/#inner-text-collection-steps>\n *\n * @param {HastNode} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n * @returns {Array.<string|BreakNumber>}\n */\nfunction innerTextCollection(node, parent, options) {\n  if (node.type === 'element') {\n    return collectElement(node, parent, options)\n  }\n\n  if (node.type === 'text') {\n    return [\n      options.whitespace === 'normal'\n        ? collectText(node, options)\n        : collectPreText(node)\n    ]\n  }\n\n  return []\n}\n\n/**\n * Collect an element.\n *\n * @param {HastElement} node\n * @param {HastParent} parent\n * @param {CollectionOptions} options\n */\nfunction collectElement(node, parent, options) {\n  // First we infer the `white-space` property.\n  const whitespace = inferWhitespace(node, options)\n  const children = node.children || []\n  let index = -1\n  /** @type {Array.<string|BreakNumber>} */\n  let items = []\n  /** @type {BreakNumber|undefined} */\n  let prefix\n  /** @type {BreakNumber|BreakForce|undefined} */\n  let suffix\n\n  // We’re ignoring point 3, and exiting without any content here, because we\n  // deviated from the spec in `toText` at step 3.\n  if (notRendered(node)) {\n    return items\n  }\n\n  // Note: we first detect if there is going to be a break before or after the\n  // contents, as that changes the white-space handling.\n\n  // 2.  If node’s computed value of `visibility` is not `visible`, then return\n  //     items.\n  //\n  //     Note: Ignored, as everything is visible by default user agent styles.\n\n  // 3.  If node is not being rendered, then return items. [...]\n  //\n  //     Note: We already did this above.\n\n  // See `collectText` for step 4.\n\n  // 5.  If node is a `<br>` element, then append a string containing a single\n  //     U+000A LINE FEED (LF) character to items.\n  if (br(node)) {\n    suffix = '\\n'\n  }\n\n  // 7.  If node’s computed value of `display` is `table-row`, and node’s CSS\n  //     box is not the last `table-row` box of the nearest ancestor `table`\n  //     box, then append a string containing a single U+000A LINE FEED (LF)\n  //     character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  //     Note: needs further investigation as this does not account for implicit\n  //     rows.\n  else if (row(node) && findAfter(parent, node, row)) {\n    suffix = '\\n'\n  }\n\n  // 8.  If node is a `<p>` element, then append 2 (a required line break count)\n  //     at the beginning and end of items.\n  else if (p(node)) {\n    prefix = 2\n    suffix = 2\n  }\n\n  // 9.  If node’s used value of `display` is block-level or `table-caption`,\n  //     then append 1 (a required line break count) at the beginning and end of\n  //     items.\n  else if (blockOrCaption(node)) {\n    prefix = 1\n    suffix = 1\n  }\n\n  // 1.  Let items be the result of running the inner text collection steps with\n  //     each child node of node in tree order, and then concatenating the\n  //     results to a single list.\n  while (++index < children.length) {\n    items = items.concat(\n      innerTextCollection(children[index], node, {\n        whitespace,\n        breakBefore: index ? undefined : prefix,\n        breakAfter:\n          index < children.length - 1 ? br(children[index + 1]) : suffix\n      })\n    )\n  }\n\n  // 6.  If node’s computed value of `display` is `table-cell`, and node’s CSS\n  //     box is not the last `table-cell` box of its enclosing `table-row` box,\n  //     then append a string containing a single U+0009 CHARACTER TABULATION\n  //     (tab) character to items.\n  //\n  //     See: <https://html.spec.whatwg.org/#tables-2>\n  if (cell(node) && findAfter(parent, node, cell)) {\n    items.push('\\t')\n  }\n\n  // Add the pre- and suffix.\n  if (prefix) items.unshift(prefix)\n  if (suffix) items.push(suffix)\n\n  return items\n}\n\n/**\n * 4.  If node is a Text node, then for each CSS text box produced by node,\n *     in content order, compute the text of the box after application of the\n *     CSS `white-space` processing rules and `text-transform` rules, set\n *     items to the list of the resulting strings, and return items.\n *     The CSS `white-space` processing rules are slightly modified:\n *     collapsible spaces at the end of lines are always collapsed, but they\n *     are only removed if the line is the last line of the block, or it ends\n *     with a br element.\n *     Soft hyphens should be preserved.\n *\n *     Note: See `collectText` and `collectPreText`.\n *     Note: we don’t deal with `text-transform`, no element has that by\n *     default.\n *\n * See: <https://drafts.csswg.org/css-text/#white-space-phase-1>\n *\n * @param {HastText|HastComment} node\n * @param {CollectionOptions} options\n * @returns {string}\n */\nfunction collectText(node, options) {\n  const value = String(node.value)\n  /** @type {Array.<string>} */\n  const lines = []\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  let index = -1\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n  /** @type {string|undefined} */\n  let join\n\n  while (start < value.length) {\n    searchLineFeeds.lastIndex = start\n    match = searchLineFeeds.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    lines.push(\n      // Any sequence of collapsible spaces and tabs immediately preceding or\n      // following a segment break is removed.\n      trimAndCollapseSpacesAndTabs(\n        // [...] ignoring bidi formatting characters (characters with the\n        // Bidi_Control property [UAX9]: ALM, LTR, RTL, LRE-RLO, LRI-PDI) as if\n        // they were not there.\n        value\n          .slice(start, end)\n          .replace(/[\\u061C\\u200E\\u200F\\u202A-\\u202E\\u2066-\\u2069]/g, ''),\n        options.breakBefore,\n        options.breakAfter\n      )\n    )\n\n    start = end + 1\n  }\n\n  // Collapsible segment breaks are transformed for rendering according to the\n  // segment break transformation rules.\n  // So here we jump to 4.1.2 of [CSSTEXT]:\n  // Any collapsible segment break immediately following another collapsible\n  // segment break is removed\n  while (++index < lines.length) {\n    // *   If the character immediately before or immediately after the segment\n    //     break is the zero-width space character (U+200B), then the break is\n    //     removed, leaving behind the zero-width space.\n    if (\n      lines[index].charCodeAt(lines[index].length - 1) === 0x200b /* ZWSP */ ||\n      (index < lines.length - 1 &&\n        lines[index + 1].charCodeAt(0) === 0x200b) /* ZWSP */\n    ) {\n      result.push(lines[index])\n      join = ''\n    }\n\n    // *   Otherwise, if the East Asian Width property [UAX11] of both the\n    //     character before and after the segment break is Fullwidth, Wide, or\n    //     Halfwidth (not Ambiguous), and neither side is Hangul, then the\n    //     segment break is removed.\n    //\n    //     Note: ignored.\n    // *   Otherwise, if the writing system of the segment break is Chinese,\n    //     Japanese, or Yi, and the character before or after the segment break\n    //     is punctuation or a symbol (Unicode general category P* or S*) and\n    //     has an East Asian Width property of Ambiguous, and the character on\n    //     the other side of the segment break is Fullwidth, Wide, or Halfwidth,\n    //     and not Hangul, then the segment break is removed.\n    //\n    //     Note: ignored.\n\n    // *   Otherwise, the segment break is converted to a space (U+0020).\n    else if (lines[index]) {\n      if (join) result.push(join)\n      result.push(lines[index])\n      join = ' '\n    }\n  }\n\n  return result.join('')\n}\n\n/**\n * @param {HastText|HastComment} node\n * @returns {string}\n */\nfunction collectPreText(node) {\n  return String(node.value)\n}\n\n/**\n * 3.  Every collapsible tab is converted to a collapsible space (U+0020).\n * 4.  Any collapsible space immediately following another collapsible\n *     space—even one outside the boundary of the inline containing that\n *     space, provided both spaces are within the same inline formatting\n *     context—is collapsed to have zero advance width. (It is invisible,\n *     but retains its soft wrap opportunity, if any.)\n *\n * @param {string} value\n * @param {BreakBefore} breakBefore\n * @param {BreakAfter} breakAfter\n * @returns {string}\n */\nfunction trimAndCollapseSpacesAndTabs(value, breakBefore, breakAfter) {\n  /** @type {Array.<string>} */\n  const result = []\n  let start = 0\n  /** @type {RegExpMatchArray|null} */\n  let match\n  /** @type {number} */\n  let end\n\n  while (start < value.length) {\n    searchTabOrSpaces.lastIndex = start\n    match = searchTabOrSpaces.exec(value)\n    // @ts-expect-error: `index` is set.\n    end = match ? match.index : value.length\n\n    // If we’re not directly after a segment break, but there was white space,\n    // add an empty value that will be turned into a space.\n    if (!start && !end && match && !breakBefore) {\n      result.push('')\n    }\n\n    if (start !== end) {\n      result.push(value.slice(start, end))\n    }\n\n    start = match ? end + match[0].length : end\n  }\n\n  // If we reached the end, there was trailing white space, and there’s no\n  // segment break after this node, add an empty value that will be turned\n  // into a space.\n  // @ts-expect-error: `end` is defined.\n  if (start !== end && !breakAfter) {\n    result.push('')\n  }\n\n  return result.join(' ')\n}\n\n/**\n * We don’t support void elements here (so `nobr wbr` -> `normal` is ignored).\n *\n * @param {HastNode} node\n * @param {CollectionOptions} options\n * @returns {Whitespace}\n */\nfunction inferWhitespace(node, options) {\n  /** @type {HastProperties} */\n  let props\n\n  if (node.type === 'element') {\n    props = node.properties || {}\n    switch (node.tagName) {\n      case 'listing':\n      case 'plaintext':\n      case 'xmp':\n        return 'pre'\n      case 'nobr':\n        return 'nowrap'\n      case 'pre':\n        return props.wrap ? 'pre-wrap' : 'pre'\n      case 'td':\n      case 'th':\n        return props.noWrap ? 'nowrap' : options.whitespace\n      case 'textarea':\n        return 'pre-wrap'\n      default:\n    }\n  }\n\n  return options.whitespace\n}\n\n/** @type {TestFunctionAnything} */\nfunction hidden(node) {\n  return Boolean((node.properties || {}).hidden)\n}\n\n/** @type {TestFunctionAnything} */\nfunction closedDialog(node) {\n  return node.tagName === 'dialog' && !(node.properties || {}).open\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}