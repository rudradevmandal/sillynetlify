{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport { ok as assert } from 'uvu/assert';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\n\nexport function mathText() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let single = options.singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  };\n  /** @type {Tokenizer} */\n\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this;\n    let sizeOpen = 0;\n    /** @type {number} */\n\n    let size;\n    /** @type {Token} */\n\n    let token;\n    return start;\n    /** @type {State} */\n\n    function start(code) {\n      assert(code === codes.dollarSign, 'expected `$`');\n      assert(previous.call(self, self.previous), 'expected correct previous');\n      effects.enter('mathText');\n      effects.enter('mathTextSequence');\n      return openingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function openingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        sizeOpen++;\n        return openingSequence;\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code);\n      effects.exit('mathTextSequence');\n      return gap(code);\n    }\n    /** @type {State} */\n\n\n    function gap(code) {\n      if (code === codes.eof) {\n        return nok(code);\n      } // Closing fence?\n      // Could also be data.\n\n\n      if (code === codes.dollarSign) {\n        token = effects.enter('mathTextSequence');\n        size = 0;\n        return closingSequence(code);\n      } // Tabs don’t work, and virtual spaces don’t make sense.\n\n\n      if (code === codes.space) {\n        effects.enter('space');\n        effects.consume(code);\n        effects.exit('space');\n        return gap;\n      }\n\n      if (markdownLineEnding(code)) {\n        effects.enter(types.lineEnding);\n        effects.consume(code);\n        effects.exit(types.lineEnding);\n        return gap;\n      } // Data.\n\n\n      effects.enter('mathTextData');\n      return data(code);\n    } // In math.\n\n    /** @type {State} */\n\n\n    function data(code) {\n      if (code === codes.eof || code === codes.space || code === codes.dollarSign || markdownLineEnding(code)) {\n        effects.exit('mathTextData');\n        return gap(code);\n      }\n\n      effects.consume(code);\n      return data;\n    } // Closing fence.\n\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      // More.\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      } // Done!\n\n\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence');\n        effects.exit('mathText');\n        return ok(code);\n      } // More or less accents: mark as data.\n\n\n      token.type = 'mathTextData';\n      return data(code);\n    }\n  }\n}\n/** @type {Resolver} */\n\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4;\n  let headEnterIndex = 3;\n  /** @type {number} */\n\n  let index;\n  /** @type {number|undefined} */\n\n  let enter; // If we start and end with an EOL or a space.\n\n  if ((events[headEnterIndex][1].type === types.lineEnding || events[headEnterIndex][1].type === 'space') && (events[tailExitIndex][1].type === types.lineEnding || events[tailExitIndex][1].type === 'space')) {\n    index = headEnterIndex; // And we have data.\n\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding';\n        events[headEnterIndex][1].type = 'mathTextPadding';\n        headEnterIndex += 2;\n        tailExitIndex -= 2;\n        break;\n      }\n    }\n  } // Merge adjacent spaces and data.\n\n\n  index = headEnterIndex - 1;\n  tailExitIndex++;\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (index !== tailExitIndex && events[index][1].type !== types.lineEnding) {\n        enter = index;\n      }\n    } else if (index === tailExitIndex || events[index][1].type === types.lineEnding) {\n      events[enter][1].type = 'mathTextData';\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end;\n        events.splice(enter + 2, index - enter - 2);\n        tailExitIndex -= index - enter - 2;\n        index = enter + 2;\n      }\n\n      enter = undefined;\n    }\n  }\n\n  return events;\n}\n/** @type {Previous} */\n\n\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return code !== codes.dollarSign || this.events[this.events.length - 1][1].type === types.characterEscape;\n}","map":{"version":3,"names":["ok","assert","markdownLineEnding","codes","types","mathText","options","single","singleDollarTextMath","undefined","tokenize","tokenizeMathText","resolve","resolveMathText","previous","effects","nok","self","sizeOpen","size","token","start","code","dollarSign","call","enter","openingSequence","consume","exit","gap","eof","closingSequence","space","lineEnding","data","type","events","tailExitIndex","length","headEnterIndex","index","end","splice","characterEscape"],"sources":["C:/Users/rudra/Documents/original_website/The-Weirdos-NFT-Website-Starter-Code/node_modules/micromark-extension-math/dev/lib/math-text.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Resolver} Resolver\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').Previous} Previous\n * @typedef {import('micromark-util-types').State} State\n * @typedef {import('micromark-util-types').Token} Token\n *\n * @typedef Options\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/**\n * @param {Options} [options]\n * @returns {Construct}\n */\nexport function mathText(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  return {\n    tokenize: tokenizeMathText,\n    resolve: resolveMathText,\n    previous\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeMathText(effects, ok, nok) {\n    const self = this\n    let sizeOpen = 0\n    /** @type {number} */\n    let size\n    /** @type {Token} */\n    let token\n\n    return start\n\n    /** @type {State} */\n    function start(code) {\n      assert(code === codes.dollarSign, 'expected `$`')\n      assert(previous.call(self, self.previous), 'expected correct previous')\n      effects.enter('mathText')\n      effects.enter('mathTextSequence')\n      return openingSequence(code)\n    }\n\n    /** @type {State} */\n    function openingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code)\n        sizeOpen++\n        return openingSequence\n      }\n\n      if (sizeOpen < 2 && !single) return nok(code)\n      effects.exit('mathTextSequence')\n      return gap(code)\n    }\n\n    /** @type {State} */\n    function gap(code) {\n      if (code === codes.eof) {\n        return nok(code)\n      }\n\n      // Closing fence?\n      // Could also be data.\n      if (code === codes.dollarSign) {\n        token = effects.enter('mathTextSequence')\n        size = 0\n        return closingSequence(code)\n      }\n\n      // Tabs don’t work, and virtual spaces don’t make sense.\n      if (code === codes.space) {\n        effects.enter('space')\n        effects.consume(code)\n        effects.exit('space')\n        return gap\n      }\n\n      if (markdownLineEnding(code)) {\n        effects.enter(types.lineEnding)\n        effects.consume(code)\n        effects.exit(types.lineEnding)\n        return gap\n      }\n\n      // Data.\n      effects.enter('mathTextData')\n      return data(code)\n    }\n\n    // In math.\n    /** @type {State} */\n    function data(code) {\n      if (\n        code === codes.eof ||\n        code === codes.space ||\n        code === codes.dollarSign ||\n        markdownLineEnding(code)\n      ) {\n        effects.exit('mathTextData')\n        return gap(code)\n      }\n\n      effects.consume(code)\n      return data\n    }\n\n    // Closing fence.\n    /** @type {State} */\n    function closingSequence(code) {\n      // More.\n      if (code === codes.dollarSign) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      // Done!\n      if (size === sizeOpen) {\n        effects.exit('mathTextSequence')\n        effects.exit('mathText')\n        return ok(code)\n      }\n\n      // More or less accents: mark as data.\n      token.type = 'mathTextData'\n      return data(code)\n    }\n  }\n}\n\n/** @type {Resolver} */\nfunction resolveMathText(events) {\n  let tailExitIndex = events.length - 4\n  let headEnterIndex = 3\n  /** @type {number} */\n  let index\n  /** @type {number|undefined} */\n  let enter\n\n  // If we start and end with an EOL or a space.\n  if (\n    (events[headEnterIndex][1].type === types.lineEnding ||\n      events[headEnterIndex][1].type === 'space') &&\n    (events[tailExitIndex][1].type === types.lineEnding ||\n      events[tailExitIndex][1].type === 'space')\n  ) {\n    index = headEnterIndex\n\n    // And we have data.\n    while (++index < tailExitIndex) {\n      if (events[index][1].type === 'mathTextData') {\n        // Then we have padding.\n        events[tailExitIndex][1].type = 'mathTextPadding'\n        events[headEnterIndex][1].type = 'mathTextPadding'\n        headEnterIndex += 2\n        tailExitIndex -= 2\n        break\n      }\n    }\n  }\n\n  // Merge adjacent spaces and data.\n  index = headEnterIndex - 1\n  tailExitIndex++\n\n  while (++index <= tailExitIndex) {\n    if (enter === undefined) {\n      if (\n        index !== tailExitIndex &&\n        events[index][1].type !== types.lineEnding\n      ) {\n        enter = index\n      }\n    } else if (\n      index === tailExitIndex ||\n      events[index][1].type === types.lineEnding\n    ) {\n      events[enter][1].type = 'mathTextData'\n\n      if (index !== enter + 2) {\n        events[enter][1].end = events[index - 1][1].end\n        events.splice(enter + 2, index - enter - 2)\n        tailExitIndex -= index - enter - 2\n        index = enter + 2\n      }\n\n      enter = undefined\n    }\n  }\n\n  return events\n}\n\n/** @type {Previous} */\nfunction previous(code) {\n  // If there is a previous code, there will always be a tail.\n  return (\n    code !== codes.dollarSign ||\n    this.events[this.events.length - 1][1].type === types.characterEscape\n  )\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}