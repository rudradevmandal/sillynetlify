{"ast":null,"code":"/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\nimport { ok as assert } from 'uvu/assert';\nimport { factorySpace } from 'micromark-factory-space';\nimport { markdownLineEnding } from 'micromark-util-character';\nimport { codes } from 'micromark-util-symbol/codes.js';\nimport { constants } from 'micromark-util-symbol/constants.js';\nimport { types } from 'micromark-util-symbol/types.js';\n/** @type {Construct} */\n\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n};\n/** @type {Construct} */\n\nconst nonLazyLine = {\n  tokenize: tokenizeNonLazyLine,\n  partial: true\n};\n/** @type {Tokenizer} */\n\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this;\n  const tail = self.events[self.events.length - 1];\n  const initialSize = tail && tail[1].type === types.linePrefix ? tail[2].sliceSerialize(tail[1], true).length : 0;\n  let sizeOpen = 0;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`');\n    effects.enter('mathFlow');\n    effects.enter('mathFlowFence');\n    effects.enter('mathFlowFenceSequence');\n    return sequenceOpen(code);\n  }\n  /** @type {State} */\n\n\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code);\n      sizeOpen++;\n      return sequenceOpen;\n    }\n\n    effects.exit('mathFlowFenceSequence');\n    return sizeOpen < 2 ? nok(code) : factorySpace(effects, metaOpen, types.whitespace)(code);\n  }\n  /** @type {State} */\n\n\n  function metaOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code);\n    }\n\n    effects.enter('mathFlowFenceMeta');\n    effects.enter(types.chunkString, {\n      contentType: constants.contentTypeString\n    });\n    return meta(code);\n  }\n  /** @type {State} */\n\n\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString);\n      effects.exit('mathFlowFenceMeta');\n      return openAfter(code);\n    }\n\n    if (code === codes.dollarSign) return nok(code);\n    effects.consume(code);\n    return meta;\n  }\n  /** @type {State} */\n\n\n  function openAfter(code) {\n    effects.exit('mathFlowFence');\n    return self.interrupt ? ok(code) : contentStart(code);\n  }\n  /** @type {State} */\n\n\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code);\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(nonLazyLine, effects.attempt({\n        tokenize: tokenizeClosingFence,\n        partial: true\n      }, after, initialSize ? factorySpace(effects, contentStart, types.linePrefix, initialSize + 1) : contentStart), after)(code);\n    }\n\n    effects.enter('mathFlowValue');\n    return contentContinue(code);\n  }\n  /** @type {State} */\n\n\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue');\n      return contentStart(code);\n    }\n\n    effects.consume(code);\n    return contentContinue;\n  }\n  /** @type {State} */\n\n\n  function after(code) {\n    effects.exit('mathFlow');\n    return ok(code);\n  }\n  /** @type {Tokenizer} */\n\n\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0;\n    return factorySpace(effects, closingPrefixAfter, types.linePrefix, constants.tabSize);\n    /** @type {State} */\n\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence');\n      effects.enter('mathFlowFenceSequence');\n      return closingSequence(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code);\n        size++;\n        return closingSequence;\n      }\n\n      if (size < sizeOpen) return nok(code);\n      effects.exit('mathFlowFenceSequence');\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code);\n    }\n    /** @type {State} */\n\n\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence');\n        return ok(code);\n      }\n\n      return nok(code);\n    }\n  }\n}\n/** @type {Tokenizer} */\n\n\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this;\n  return start;\n  /** @type {State} */\n\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol');\n    effects.enter(types.lineEnding);\n    effects.consume(code);\n    effects.exit(types.lineEnding);\n    return lineStart;\n  }\n  /** @type {State} */\n\n\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code);\n  }\n}","map":{"version":3,"names":["ok","assert","factorySpace","markdownLineEnding","codes","constants","types","mathFlow","tokenize","tokenizeMathFenced","concrete","nonLazyLine","tokenizeNonLazyLine","partial","effects","nok","self","tail","events","length","initialSize","type","linePrefix","sliceSerialize","sizeOpen","start","code","dollarSign","enter","sequenceOpen","consume","exit","metaOpen","whitespace","eof","openAfter","chunkString","contentType","contentTypeString","meta","interrupt","contentStart","after","attempt","tokenizeClosingFence","contentContinue","size","closingPrefixAfter","tabSize","closingSequence","closingSequenceEnd","lineEnding","lineStart","parser","lazy","now","line"],"sources":["C:/Users/rudra/Documents/original_website/The-Weirdos-NFT-Website-Starter-Code/node_modules/micromark-extension-math/dev/lib/math-flow.js"],"sourcesContent":["/**\n * @typedef {import('micromark-util-types').Construct} Construct\n * @typedef {import('micromark-util-types').Tokenizer} Tokenizer\n * @typedef {import('micromark-util-types').State} State\n */\n\nimport {ok as assert} from 'uvu/assert'\nimport {factorySpace} from 'micromark-factory-space'\nimport {markdownLineEnding} from 'micromark-util-character'\nimport {codes} from 'micromark-util-symbol/codes.js'\nimport {constants} from 'micromark-util-symbol/constants.js'\nimport {types} from 'micromark-util-symbol/types.js'\n\n/** @type {Construct} */\nexport const mathFlow = {\n  tokenize: tokenizeMathFenced,\n  concrete: true\n}\n\n/** @type {Construct} */\nconst nonLazyLine = {tokenize: tokenizeNonLazyLine, partial: true}\n\n/** @type {Tokenizer} */\nfunction tokenizeMathFenced(effects, ok, nok) {\n  const self = this\n  const tail = self.events[self.events.length - 1]\n  const initialSize =\n    tail && tail[1].type === types.linePrefix\n      ? tail[2].sliceSerialize(tail[1], true).length\n      : 0\n  let sizeOpen = 0\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(code === codes.dollarSign, 'expected `$`')\n    effects.enter('mathFlow')\n    effects.enter('mathFlowFence')\n    effects.enter('mathFlowFenceSequence')\n    return sequenceOpen(code)\n  }\n\n  /** @type {State} */\n  function sequenceOpen(code) {\n    if (code === codes.dollarSign) {\n      effects.consume(code)\n      sizeOpen++\n      return sequenceOpen\n    }\n\n    effects.exit('mathFlowFenceSequence')\n    return sizeOpen < 2\n      ? nok(code)\n      : factorySpace(effects, metaOpen, types.whitespace)(code)\n  }\n\n  /** @type {State} */\n  function metaOpen(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      return openAfter(code)\n    }\n\n    effects.enter('mathFlowFenceMeta')\n    effects.enter(types.chunkString, {contentType: constants.contentTypeString})\n    return meta(code)\n  }\n\n  /** @type {State} */\n  function meta(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit(types.chunkString)\n      effects.exit('mathFlowFenceMeta')\n      return openAfter(code)\n    }\n\n    if (code === codes.dollarSign) return nok(code)\n    effects.consume(code)\n    return meta\n  }\n\n  /** @type {State} */\n  function openAfter(code) {\n    effects.exit('mathFlowFence')\n    return self.interrupt ? ok(code) : contentStart(code)\n  }\n\n  /** @type {State} */\n  function contentStart(code) {\n    if (code === codes.eof) {\n      return after(code)\n    }\n\n    if (markdownLineEnding(code)) {\n      return effects.attempt(\n        nonLazyLine,\n        effects.attempt(\n          {tokenize: tokenizeClosingFence, partial: true},\n          after,\n          initialSize\n            ? factorySpace(\n                effects,\n                contentStart,\n                types.linePrefix,\n                initialSize + 1\n              )\n            : contentStart\n        ),\n        after\n      )(code)\n    }\n\n    effects.enter('mathFlowValue')\n    return contentContinue(code)\n  }\n\n  /** @type {State} */\n  function contentContinue(code) {\n    if (code === codes.eof || markdownLineEnding(code)) {\n      effects.exit('mathFlowValue')\n      return contentStart(code)\n    }\n\n    effects.consume(code)\n    return contentContinue\n  }\n\n  /** @type {State} */\n  function after(code) {\n    effects.exit('mathFlow')\n    return ok(code)\n  }\n\n  /** @type {Tokenizer} */\n  function tokenizeClosingFence(effects, ok, nok) {\n    let size = 0\n\n    return factorySpace(\n      effects,\n      closingPrefixAfter,\n      types.linePrefix,\n      constants.tabSize\n    )\n\n    /** @type {State} */\n    function closingPrefixAfter(code) {\n      effects.enter('mathFlowFence')\n      effects.enter('mathFlowFenceSequence')\n      return closingSequence(code)\n    }\n\n    /** @type {State} */\n    function closingSequence(code) {\n      if (code === codes.dollarSign) {\n        effects.consume(code)\n        size++\n        return closingSequence\n      }\n\n      if (size < sizeOpen) return nok(code)\n      effects.exit('mathFlowFenceSequence')\n      return factorySpace(effects, closingSequenceEnd, types.whitespace)(code)\n    }\n\n    /** @type {State} */\n    function closingSequenceEnd(code) {\n      if (code === codes.eof || markdownLineEnding(code)) {\n        effects.exit('mathFlowFence')\n        return ok(code)\n      }\n\n      return nok(code)\n    }\n  }\n}\n\n/** @type {Tokenizer} */\nfunction tokenizeNonLazyLine(effects, ok, nok) {\n  const self = this\n\n  return start\n\n  /** @type {State} */\n  function start(code) {\n    assert(markdownLineEnding(code), 'expected eol')\n    effects.enter(types.lineEnding)\n    effects.consume(code)\n    effects.exit(types.lineEnding)\n    return lineStart\n  }\n\n  /** @type {State} */\n  function lineStart(code) {\n    return self.parser.lazy[self.now().line] ? nok(code) : ok(code)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}