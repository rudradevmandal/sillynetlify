{"ast":null,"code":"/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\nimport { longestStreak } from 'longest-streak';\nimport { safe } from 'mdast-util-to-markdown/lib/util/safe.js';\nimport { track } from 'mdast-util-to-markdown/lib/util/track.js';\n/**\n * @returns {FromMarkdownExtension}\n */\n\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  };\n  /** @type {FromMarkdownHandle} */\n\n  function enterMathFlow(token) {\n    this.enter({\n      type: 'math',\n      meta: null,\n      value: '',\n      data: {\n        hName: 'div',\n        hProperties: {\n          className: ['math', 'math-display']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterMathFlowMeta() {\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlowMeta() {\n    const data = this.resume();\n    const node =\n    /** @type {Math} */\n    this.stack[this.stack.length - 1];\n    node.meta = data;\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return;\n    this.buffer();\n    this.setData('mathFlowInside', true);\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '');\n    const node =\n    /** @type {Math} */\n    this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n    this.setData('mathFlowInside');\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function enterMathText(token) {\n    this.enter({\n      type: 'inlineMath',\n      value: '',\n      data: {\n        hName: 'span',\n        hProperties: {\n          className: ['math', 'math-inline']\n        },\n        hChildren: [{\n          type: 'text',\n          value: ''\n        }]\n      }\n    }, token);\n    this.buffer();\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathText(token) {\n    const data = this.resume();\n    const node =\n    /** @type {Math} */\n    this.exit(token);\n    node.value = data; // @ts-expect-error: we defined it.\n\n    node.data.hChildren[0].value = data;\n  }\n  /** @type {FromMarkdownHandle} */\n\n\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token);\n    this.config.exit.data.call(this, token);\n  }\n}\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\n\nexport function mathToMarkdown() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let single = options.singleDollarTextMath;\n\n  if (single === null || single === undefined) {\n    single = true;\n  }\n\n  inlineMath.peek = inlineMathPeek;\n  return {\n    unsafe: [{\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, {\n      character: '\\r',\n      inConstruct: ['mathFlowMeta']\n    }, single ? {\n      character: '$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    } : {\n      character: '$',\n      after: '\\\\$',\n      inConstruct: ['mathFlowMeta', 'phrasing']\n    }, {\n      atBreak: true,\n      character: '$',\n      after: '\\\\$'\n    }],\n    handlers: {\n      math,\n      inlineMath\n    }\n  };\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || '';\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2));\n    const exit = context.enter('mathFlow');\n    const tracker = track(safeOptions);\n    let value = tracker.move(sequence);\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta');\n      value += tracker.move(safe(context, node.meta, { ...tracker.current(),\n        before: value,\n        after: ' ',\n        encode: ['$']\n      }));\n      subexit();\n    }\n\n    value += tracker.move('\\n');\n\n    if (raw) {\n      value += tracker.move(raw + '\\n');\n    }\n\n    value += tracker.move(sequence);\n    exit();\n    return value;\n  }\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n\n\n  function inlineMath(node) {\n    const value = node.value || '';\n    let size = 1;\n    let pad = '';\n    if (!single) size++; // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n\n    while (new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)) {\n      size++;\n    } // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n\n\n    if (/[^ \\r\\n]/.test(value) && (/[ \\r\\n$]/.test(value.charAt(0)) || /[ \\r\\n$]/.test(value.charAt(value.length - 1)))) {\n      pad = ' ';\n    }\n\n    const sequence = '$'.repeat(size);\n    return sequence + pad + value + pad + sequence;\n  }\n  /** @type {ToMarkdownHandle} */\n\n\n  function inlineMathPeek() {\n    return '$';\n  }\n}","map":{"version":3,"names":["longestStreak","safe","track","mathFromMarkdown","enter","mathFlow","enterMathFlow","mathFlowFenceMeta","enterMathFlowMeta","mathText","enterMathText","exit","exitMathFlow","mathFlowFence","exitMathFlowFence","exitMathFlowMeta","mathFlowValue","exitMathData","exitMathText","mathTextData","token","type","meta","value","data","hName","hProperties","className","hChildren","buffer","resume","node","stack","length","getData","setData","replace","config","call","mathToMarkdown","options","single","singleDollarTextMath","undefined","inlineMath","peek","inlineMathPeek","unsafe","character","inConstruct","after","atBreak","handlers","math","_","context","safeOptions","raw","sequence","repeat","Math","max","tracker","move","subexit","current","before","encode","size","pad","RegExp","test","charAt"],"sources":["C:/Users/rudra/Documents/original_website/The-Weirdos-NFT-Website-Starter-Code/node_modules/mdast-util-math/index.js"],"sourcesContent":["/**\n * @typedef {import('mdast-util-from-markdown').Extension} FromMarkdownExtension\n * @typedef {import('mdast-util-from-markdown').Handle} FromMarkdownHandle\n * @typedef {import('mdast-util-to-markdown').Options} ToMarkdownExtension\n * @typedef {import('mdast-util-to-markdown').Handle} ToMarkdownHandle\n * @typedef {import('./complex-types').Math} Math\n * @typedef {import('./complex-types').InlineMath} InlineMath\n *\n * @typedef ToOptions\n * @property {boolean} [singleDollarTextMath=true]\n *   Whether to support math (text) with a single dollar (`boolean`, default:\n *   `true`).\n *   Single dollars work in Pandoc and many other places, but often interfere\n *   with “normal” dollars in text.\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {safe} from 'mdast-util-to-markdown/lib/util/safe.js'\nimport {track} from 'mdast-util-to-markdown/lib/util/track.js'\n\n/**\n * @returns {FromMarkdownExtension}\n */\nexport function mathFromMarkdown() {\n  return {\n    enter: {\n      mathFlow: enterMathFlow,\n      mathFlowFenceMeta: enterMathFlowMeta,\n      mathText: enterMathText\n    },\n    exit: {\n      mathFlow: exitMathFlow,\n      mathFlowFence: exitMathFlowFence,\n      mathFlowFenceMeta: exitMathFlowMeta,\n      mathFlowValue: exitMathData,\n      mathText: exitMathText,\n      mathTextData: exitMathData\n    }\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlow(token) {\n    this.enter(\n      {\n        type: 'math',\n        meta: null,\n        value: '',\n        data: {\n          hName: 'div',\n          hProperties: {className: ['math', 'math-display']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathFlowMeta() {\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowMeta() {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.stack[this.stack.length - 1])\n    node.meta = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlowFence() {\n    // Exit if this is the closing fence.\n    if (this.getData('mathFlowInside')) return\n    this.buffer()\n    this.setData('mathFlowInside', true)\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathFlow(token) {\n    const data = this.resume().replace(/^(\\r?\\n|\\r)|(\\r?\\n|\\r)$/g, '')\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n    this.setData('mathFlowInside')\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function enterMathText(token) {\n    this.enter(\n      {\n        type: 'inlineMath',\n        value: '',\n        data: {\n          hName: 'span',\n          hProperties: {className: ['math', 'math-inline']},\n          hChildren: [{type: 'text', value: ''}]\n        }\n      },\n      token\n    )\n    this.buffer()\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathText(token) {\n    const data = this.resume()\n    const node = /** @type {Math} */ (this.exit(token))\n    node.value = data\n    // @ts-expect-error: we defined it.\n    node.data.hChildren[0].value = data\n  }\n\n  /** @type {FromMarkdownHandle} */\n  function exitMathData(token) {\n    this.config.enter.data.call(this, token)\n    this.config.exit.data.call(this, token)\n  }\n}\n\n/**\n * @param {ToOptions} [options]\n * @returns {ToMarkdownExtension}\n */\nexport function mathToMarkdown(options = {}) {\n  let single = options.singleDollarTextMath\n\n  if (single === null || single === undefined) {\n    single = true\n  }\n\n  inlineMath.peek = inlineMathPeek\n\n  return {\n    unsafe: [\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      {character: '\\r', inConstruct: ['mathFlowMeta']},\n      single\n        ? {character: '$', inConstruct: ['mathFlowMeta', 'phrasing']}\n        : {\n            character: '$',\n            after: '\\\\$',\n            inConstruct: ['mathFlowMeta', 'phrasing']\n          },\n      {atBreak: true, character: '$', after: '\\\\$'}\n    ],\n    handlers: {math, inlineMath}\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {Math} node\n   */\n  function math(node, _, context, safeOptions) {\n    const raw = node.value || ''\n    const sequence = '$'.repeat(Math.max(longestStreak(raw, '$') + 1, 2))\n    const exit = context.enter('mathFlow')\n    const tracker = track(safeOptions)\n    let value = tracker.move(sequence)\n\n    if (node.meta) {\n      const subexit = context.enter('mathFlowMeta')\n      value += tracker.move(\n        safe(context, node.meta, {\n          ...tracker.current(),\n          before: value,\n          after: ' ',\n          encode: ['$']\n        })\n      )\n      subexit()\n    }\n\n    value += tracker.move('\\n')\n\n    if (raw) {\n      value += tracker.move(raw + '\\n')\n    }\n\n    value += tracker.move(sequence)\n    exit()\n    return value\n  }\n\n  /**\n   * @type {ToMarkdownHandle}\n   * @param {InlineMath} node\n   */\n  function inlineMath(node) {\n    const value = node.value || ''\n    let size = 1\n    let pad = ''\n\n    if (!single) size++\n\n    // If there is a single dollar sign on its own in the math, use a fence of\n    // two.\n    // If there are two in a row, use one.\n    while (\n      new RegExp('(^|[^$])' + '\\\\$'.repeat(size) + '([^$]|$)').test(value)\n    ) {\n      size++\n    }\n\n    // If this is not just spaces or eols (tabs don’t count), and either the first\n    // or last character are a space, eol, or dollar sign, then pad with spaces.\n    if (\n      /[^ \\r\\n]/.test(value) &&\n      (/[ \\r\\n$]/.test(value.charAt(0)) ||\n        /[ \\r\\n$]/.test(value.charAt(value.length - 1)))\n    ) {\n      pad = ' '\n    }\n\n    const sequence = '$'.repeat(size)\n    return sequence + pad + value + pad + sequence\n  }\n\n  /** @type {ToMarkdownHandle} */\n  function inlineMathPeek() {\n    return '$'\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}